{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"KVM & QEMU Notlar\u0131 Merhaba Bu sayfa Qemu ve KVM \u00fczerine \u00e7al\u0131\u015f\u0131rken al\u0131nm\u0131\u015f baz\u0131 notlard\u0131r. QEMU Nedir QEMU (Quick Emulator) ihtiya\u00e7 duyulan donan\u0131mlar\u0131 h\u0131zl\u0131 bir \u015fekilde taklit edebilecek bir em\u00fclat\u00f6rd\u00fcr. QEMU farkl\u0131 CPU \u00e7e\u015fitlerini (x86, PowerPC, ARM vb.) farkl\u0131 mimarilerde (x86, PowerPC, ARM, Sparc, MIPS vb.) kullanmaya izin vermektedir. Ayn\u0131 zamanda donan\u0131m ile sanalla\u015ft\u0131rmay\u0131 da desteklemektedir. K\u0131saca QEMU'nun temel \u00f6zelliklerini \u015fu \u015fekilde s\u0131ral\u0131yabiliriz. Full Em\u00fclat\u00f6r Dynamic Translation KVM ile birlikte kullan\u0131larak sanalla\u015ft\u0131rma yapabilmektedir. QEMU Tarih\u00e7esi QEMU 2003 y\u0131l\u0131nda Fabrice Bellard taraf\u0131ndan duyurulmu\u015f ve GPLv2 ile lisanslanm\u0131\u015ft\u0131r. Ayn\u0131 zamanda program\u0131n baz\u0131 par\u00e7alar\u0131 da BSD lisans\u0131 ile lisanslanm\u0131\u015ft\u0131r. \u015eu an bir \u00e7ok farkl\u0131 b\u00f6l\u00fcme ayr\u0131lan QEMU projesi \u00f6zellikle RedHat ekibi taraf\u0131ndan g\u00fcncel tutulmaktad\u0131r. Ayn\u0131 zamanda b\u00fcy\u00fck bir topluluk deste\u011fi ile birlikte geli\u015ftirilmektedir. Guest CPU cores (TCG) FPU emulation ARM TCG CPUs AVR TCG CPUs MIPS TCG CPUs OpenRISC TCG CPUs PowerPC TCG CPUs RISC-V TCG CPUs ....... T\u00fcm listeye maintainer referanslar\u0131ndan ula\u015f\u0131labilir. Qemu Kaynak Kodunun \u0130ncelenmesi Bu yaz\u0131da QEMU\u2019nun kaynak kodu temel seviyede incelenecektir. Bu ba\u011flamda ilk olarak, QEMU\u2019nun ba\u015flang\u0131c\u0131nda \u00e7al\u0131\u015ft\u0131r\u0131lan main fonksiyonu incelenecektir. Main fonksiyonu QEMU/softmmu/main.c klas\u00f6r\u00fc alt\u0131nda bulunur. main fonksiyonu i\u00e7erisinde sadece 3 fonkisyon \u00e7a\u011fr\u0131l\u0131r. qemu_init() qemu_main_loop() qemu_cleanup() int main(int argc, char **argv, char **envp) { qemu_init(argc, argv, envp); qemu_main_loop(); qemu_cleanup(); return 0; } Fonksiyon A\u00e7\u0131klama qemu_init_subsystems() - cpu_list, cpu_loop, crypto init ediliyor qemu_validate_options() - QEMU'ya verilen ayarlar burada kontrol edilmekte ve olu\u015fabilicek yanl\u0131\u015flar\u0131n \u00f6n\u00fcne ge\u00e7ilmektedir qemu_process_early_options() - ? + log dosyalar\u0131 haz\u0131rlan\u0131yor qemu_init_main_loop() - QEMU, main_loop'un ba\u015flamas\u0131 i\u00e7in \u00f6n haz\u0131rl\u0131kl\u0131klar\u0131 yapmaktad\u0131r. cpu_timer_init() - QEMU, CPU i\u00e7in \u00e7al\u0131\u015facak ger\u00e7ek zamanl\u0131 saatin frekans ve geri kalan ayarlar\u0131n\u0131 yapmaktad\u0131r configure_rtc() - QEMU, RTC ayarlar\u0131 yap\u0131l\u0131yor (UTC) qemu_create_machine() - QEMU, sim\u00fcle edilecek cihaz\u0131 olu\u015fturmaktad\u0131r qemu_disable_default_devices() - Sanal cihaza ba\u011fl\u0131 seri ba\u011flant\u0131lar (SD kart, CD-ROM) ve grafik hizmetleri durdurulur. qemu_create_default_devices() - Serial ve grafik cihazlar\u0131n\u0131 olu\u015fturulur. qemu_create_early_backends() - ??? configure_accelerators() - Kullan\u0131lacak h\u0131zland\u0131r\u0131c\u0131 se\u00e7ilmektedir bunlar kvm veya tcg olabilmektedir. migration_object_init() - ??? qemu_create_late_backends() - ??? accel_init_interfaces() - CPU aray\u00fczleri ba\u015flat\u0131l\u0131r. qemu_init_displays() - Lokal ve uzak displayler ba\u015flat\u0131l\u0131r. os_setup_post()","title":"Qemu"},{"location":"#kvm-qemu-notlar","text":"Merhaba Bu sayfa Qemu ve KVM \u00fczerine \u00e7al\u0131\u015f\u0131rken al\u0131nm\u0131\u015f baz\u0131 notlard\u0131r.","title":"KVM &amp; QEMU Notlar\u0131"},{"location":"#qemu-nedir","text":"QEMU (Quick Emulator) ihtiya\u00e7 duyulan donan\u0131mlar\u0131 h\u0131zl\u0131 bir \u015fekilde taklit edebilecek bir em\u00fclat\u00f6rd\u00fcr. QEMU farkl\u0131 CPU \u00e7e\u015fitlerini (x86, PowerPC, ARM vb.) farkl\u0131 mimarilerde (x86, PowerPC, ARM, Sparc, MIPS vb.) kullanmaya izin vermektedir. Ayn\u0131 zamanda donan\u0131m ile sanalla\u015ft\u0131rmay\u0131 da desteklemektedir. K\u0131saca QEMU'nun temel \u00f6zelliklerini \u015fu \u015fekilde s\u0131ral\u0131yabiliriz. Full Em\u00fclat\u00f6r Dynamic Translation KVM ile birlikte kullan\u0131larak sanalla\u015ft\u0131rma yapabilmektedir.","title":"QEMU Nedir"},{"location":"#qemu-tarihcesi","text":"QEMU 2003 y\u0131l\u0131nda Fabrice Bellard taraf\u0131ndan duyurulmu\u015f ve GPLv2 ile lisanslanm\u0131\u015ft\u0131r. Ayn\u0131 zamanda program\u0131n baz\u0131 par\u00e7alar\u0131 da BSD lisans\u0131 ile lisanslanm\u0131\u015ft\u0131r. \u015eu an bir \u00e7ok farkl\u0131 b\u00f6l\u00fcme ayr\u0131lan QEMU projesi \u00f6zellikle RedHat ekibi taraf\u0131ndan g\u00fcncel tutulmaktad\u0131r. Ayn\u0131 zamanda b\u00fcy\u00fck bir topluluk deste\u011fi ile birlikte geli\u015ftirilmektedir. Guest CPU cores (TCG) FPU emulation ARM TCG CPUs AVR TCG CPUs MIPS TCG CPUs OpenRISC TCG CPUs PowerPC TCG CPUs RISC-V TCG CPUs ....... T\u00fcm listeye maintainer referanslar\u0131ndan ula\u015f\u0131labilir.","title":"QEMU Tarih\u00e7esi"},{"location":"#qemu-kaynak-kodunun-incelenmesi","text":"Bu yaz\u0131da QEMU\u2019nun kaynak kodu temel seviyede incelenecektir. Bu ba\u011flamda ilk olarak, QEMU\u2019nun ba\u015flang\u0131c\u0131nda \u00e7al\u0131\u015ft\u0131r\u0131lan main fonksiyonu incelenecektir. Main fonksiyonu QEMU/softmmu/main.c klas\u00f6r\u00fc alt\u0131nda bulunur. main fonksiyonu i\u00e7erisinde sadece 3 fonkisyon \u00e7a\u011fr\u0131l\u0131r. qemu_init() qemu_main_loop() qemu_cleanup() int main(int argc, char **argv, char **envp) { qemu_init(argc, argv, envp); qemu_main_loop(); qemu_cleanup(); return 0; } Fonksiyon A\u00e7\u0131klama qemu_init_subsystems() - cpu_list, cpu_loop, crypto init ediliyor qemu_validate_options() - QEMU'ya verilen ayarlar burada kontrol edilmekte ve olu\u015fabilicek yanl\u0131\u015flar\u0131n \u00f6n\u00fcne ge\u00e7ilmektedir qemu_process_early_options() - ? + log dosyalar\u0131 haz\u0131rlan\u0131yor qemu_init_main_loop() - QEMU, main_loop'un ba\u015flamas\u0131 i\u00e7in \u00f6n haz\u0131rl\u0131kl\u0131klar\u0131 yapmaktad\u0131r. cpu_timer_init() - QEMU, CPU i\u00e7in \u00e7al\u0131\u015facak ger\u00e7ek zamanl\u0131 saatin frekans ve geri kalan ayarlar\u0131n\u0131 yapmaktad\u0131r configure_rtc() - QEMU, RTC ayarlar\u0131 yap\u0131l\u0131yor (UTC) qemu_create_machine() - QEMU, sim\u00fcle edilecek cihaz\u0131 olu\u015fturmaktad\u0131r qemu_disable_default_devices() - Sanal cihaza ba\u011fl\u0131 seri ba\u011flant\u0131lar (SD kart, CD-ROM) ve grafik hizmetleri durdurulur. qemu_create_default_devices() - Serial ve grafik cihazlar\u0131n\u0131 olu\u015fturulur. qemu_create_early_backends() - ??? configure_accelerators() - Kullan\u0131lacak h\u0131zland\u0131r\u0131c\u0131 se\u00e7ilmektedir bunlar kvm veya tcg olabilmektedir. migration_object_init() - ??? qemu_create_late_backends() - ??? accel_init_interfaces() - CPU aray\u00fczleri ba\u015flat\u0131l\u0131r. qemu_init_displays() - Lokal ve uzak displayler ba\u015flat\u0131l\u0131r. os_setup_post()","title":"Qemu Kaynak Kodunun \u0130ncelenmesi"},{"location":"ekler/","text":"Ekler QEMU'nun Derlenmesi QEMU'yu derlememiz i\u00e7in \u00f6ncelikle baz\u0131 paketleri indirmemiz gerekmektedir. Bunun i\u00e7in: sudo apt-get install git libglib2.0-dev libfdt-dev libpixman-1-dev zlib1g-dev QEMU'nun g\u00fcncel kaynak kodunu \u00e7ekelim. git clone git://git.qemu-project.org/qemu.git QEMU'yu derleyelim. cd qemu mkdir -p bin/debug/native cd bin/debug/native ../../../configure --enable-debug make cd ../../.. QEMU \u00fczerinde k\u00fc\u00e7\u00fck bir test yaparak denemeyi sonland\u0131ral\u0131m. bin/debug/native/x86_64-softmmu/qemu-system-x86_64 -L pc-bios Meson Build Sistemi Asl\u0131nda klas\u00f6r yap\u0131s\u0131 ile alakal\u0131 de\u011fil ancak burada \u00e7ok kullan\u0131ld\u0131\u011f\u0131 i\u00e7in meson hakk\u0131nda da k\u0131saca bahsetmek istiyorum. Meson sayesinde projeleri otomatik bir \u015fekilde build etmek m\u00fcmk\u00fcn olmaktad\u0131r. Ayn\u0131 zamanda Apache2 ile lisanslanm\u0131\u015ft\u0131r ve bir \u00e7ok a\u00e7\u0131k kaynak projede kullan\u0131lmaktad\u0131r. \u00d6rne\u011fin: GNOME ( ve GNOME uygulamalar\u0131 ) Libvirt QEMU X.Org Tan\u0131mlar x86: Intel'in 8086 mikroi\u015flemcisini ve onun 8088 varyant\u0131n\u0131 temel alarak Intel taraf\u0131ndan geli\u015ftiren bir buyruk k\u00fcmesi mimarisi ailesidir. PowerPC: PowerPC, AIM olarak bilinen 1991\u2019de Apple_IBM_Motorola birle\u015fimi taraf\u0131ndan meydana getirilmi\u015f bir RISC mikroi\u015flemcisidir ARM: D\u00fc\u015f\u00fck g\u00fc\u00e7 t\u00fcketimi ve y\u00fcksek performansl\u0131 RISC tabanl\u0131 bir i\u015flemci mimarisidir. Em\u00fclat\u00f6r: Farkl\u0131 mimarilerde donan\u0131mlar\u0131 taklit ederek bu donan\u0131mlar\u0131 \u00e7al\u0131\u015ft\u0131ran sistemlerdir. Sanalla\u015ft\u0131rma: \u0130\u015fletim sistemlerini birbirlerinden izole hale getirerek ayn\u0131 cihazda birden \u00e7ok i\u015fletim sistemini \u00e7al\u0131\u015ft\u0131rma i\u015flemidir. GPLv2 Lisans\u0131: GPLv2 lisans\u0131 \u00f6zg\u00fcr bir yaz\u0131l\u0131m lisans\u0131d\u0131r. Lisans detaylar\u0131na https://www.gnu.org/licenses/old-licenses/gpl-2.0.html adresinden ula\u015f\u0131labilir. GPLv3 Lisans\u0131: GPLv3 lisans\u0131 \u00f6zg\u00fcr bir yaz\u0131l\u0131m lisans\u0131d\u0131r. Lisans detaylar\u0131na https://www.gnu.org/licenses/gpl-3.0.html adresinden ula\u015f\u0131labilir. BSD Lisans\u0131: BSD lisanlar\u0131 \u00f6zg\u00fcr yaz\u0131l\u0131m lisanlar\u0131 aras\u0131na girmektedir. Lisans\u0131n detaylar\u0131na https://opensource.org/licenses/BSD-3-Clause ula\u015f\u0131labilir. Apache2 Lisans\u0131: Redhat: Red Hat, \u00f6zellikle a\u00e7\u0131k kaynak projeler ile profesyonel \u00e7\u00f6z\u00fcmler sunan yaz\u0131l\u0131m \u015firketidir. FPU (Floating Point Unit): CPU \u00fczerinde bulunmaktad\u0131r ve hassas hesaplamalarda g\u00f6rev almaktad\u0131r. Stub: Bilgisayar bilimlerinde bir kodun test edilebilmesi i\u00e7in haz\u0131rlanm\u0131\u015f uydurulmu\u015f verilerdir.","title":"Ekler"},{"location":"ekler/#ekler","text":"","title":"Ekler"},{"location":"ekler/#qemunun-derlenmesi","text":"QEMU'yu derlememiz i\u00e7in \u00f6ncelikle baz\u0131 paketleri indirmemiz gerekmektedir. Bunun i\u00e7in: sudo apt-get install git libglib2.0-dev libfdt-dev libpixman-1-dev zlib1g-dev QEMU'nun g\u00fcncel kaynak kodunu \u00e7ekelim. git clone git://git.qemu-project.org/qemu.git QEMU'yu derleyelim. cd qemu mkdir -p bin/debug/native cd bin/debug/native ../../../configure --enable-debug make cd ../../.. QEMU \u00fczerinde k\u00fc\u00e7\u00fck bir test yaparak denemeyi sonland\u0131ral\u0131m. bin/debug/native/x86_64-softmmu/qemu-system-x86_64 -L pc-bios","title":"QEMU'nun Derlenmesi"},{"location":"ekler/#meson-build-sistemi","text":"Asl\u0131nda klas\u00f6r yap\u0131s\u0131 ile alakal\u0131 de\u011fil ancak burada \u00e7ok kullan\u0131ld\u0131\u011f\u0131 i\u00e7in meson hakk\u0131nda da k\u0131saca bahsetmek istiyorum. Meson sayesinde projeleri otomatik bir \u015fekilde build etmek m\u00fcmk\u00fcn olmaktad\u0131r. Ayn\u0131 zamanda Apache2 ile lisanslanm\u0131\u015ft\u0131r ve bir \u00e7ok a\u00e7\u0131k kaynak projede kullan\u0131lmaktad\u0131r. \u00d6rne\u011fin: GNOME ( ve GNOME uygulamalar\u0131 ) Libvirt QEMU X.Org","title":"Meson Build Sistemi"},{"location":"ekler/#tanmlar","text":"x86: Intel'in 8086 mikroi\u015flemcisini ve onun 8088 varyant\u0131n\u0131 temel alarak Intel taraf\u0131ndan geli\u015ftiren bir buyruk k\u00fcmesi mimarisi ailesidir. PowerPC: PowerPC, AIM olarak bilinen 1991\u2019de Apple_IBM_Motorola birle\u015fimi taraf\u0131ndan meydana getirilmi\u015f bir RISC mikroi\u015flemcisidir ARM: D\u00fc\u015f\u00fck g\u00fc\u00e7 t\u00fcketimi ve y\u00fcksek performansl\u0131 RISC tabanl\u0131 bir i\u015flemci mimarisidir. Em\u00fclat\u00f6r: Farkl\u0131 mimarilerde donan\u0131mlar\u0131 taklit ederek bu donan\u0131mlar\u0131 \u00e7al\u0131\u015ft\u0131ran sistemlerdir. Sanalla\u015ft\u0131rma: \u0130\u015fletim sistemlerini birbirlerinden izole hale getirerek ayn\u0131 cihazda birden \u00e7ok i\u015fletim sistemini \u00e7al\u0131\u015ft\u0131rma i\u015flemidir. GPLv2 Lisans\u0131: GPLv2 lisans\u0131 \u00f6zg\u00fcr bir yaz\u0131l\u0131m lisans\u0131d\u0131r. Lisans detaylar\u0131na https://www.gnu.org/licenses/old-licenses/gpl-2.0.html adresinden ula\u015f\u0131labilir. GPLv3 Lisans\u0131: GPLv3 lisans\u0131 \u00f6zg\u00fcr bir yaz\u0131l\u0131m lisans\u0131d\u0131r. Lisans detaylar\u0131na https://www.gnu.org/licenses/gpl-3.0.html adresinden ula\u015f\u0131labilir. BSD Lisans\u0131: BSD lisanlar\u0131 \u00f6zg\u00fcr yaz\u0131l\u0131m lisanlar\u0131 aras\u0131na girmektedir. Lisans\u0131n detaylar\u0131na https://opensource.org/licenses/BSD-3-Clause ula\u015f\u0131labilir. Apache2 Lisans\u0131: Redhat: Red Hat, \u00f6zellikle a\u00e7\u0131k kaynak projeler ile profesyonel \u00e7\u00f6z\u00fcmler sunan yaz\u0131l\u0131m \u015firketidir. FPU (Floating Point Unit): CPU \u00fczerinde bulunmaktad\u0131r ve hassas hesaplamalarda g\u00f6rev almaktad\u0131r. Stub: Bilgisayar bilimlerinde bir kodun test edilebilmesi i\u00e7in haz\u0131rlanm\u0131\u015f uydurulmu\u015f verilerdir.","title":"Tan\u0131mlar"},{"location":"kvm/","text":"KVM Nedir KVM, Linux \u00e7ekirde\u011fini tip-1 hypervisor'e d\u00f6n\u00fc\u015ft\u00fcren bir mod\u00fcld\u00fcr. Ayn\u0131 zamanda QEMU ile birle\u015ferek tip-2 hyperviz\u00f6r'e d\u00f6n\u00fc\u015ft\u00fcrebilmektedir. X86 i\u015flemciler i\u00e7in tasarlanm\u0131\u015ft\u0131r. KVM, sanalla\u015ft\u0131rmak i\u00e7in Intel VT-x veya AMD-V gibi \u00f6zel donan\u0131m gerektirir. KVM geli\u015ftiricileri Popek ve Goldberg'in \u00f6nerdi\u011fi 3 temel \u015fart\u0131 \u015fu \u015fekilde sa\u011flam\u0131\u015flard\u0131r. Equivalence: KVM, herhangi bir i\u015fletim sistemi fark\u0131 olmadan ve bir de\u011fi\u015fiklik yapmadan herhangi bir x86 i\u015fletim sistemini \u00e7al\u0131\u015ft\u0131rabilmelidir. Safety: KVM, sanal makineler aras\u0131nda b\u00fct\u00fcn bir izolasyon sa\u011flamaktad\u0131r. Bunun i\u00e7in CPU, fiziksel haf\u0131za, BIOS yaz\u0131l\u0131m\u0131 gibi par\u00e7alar da sanalla\u015ft\u0131r\u0131lmaktad\u0131r. Bununla birlikte k\u00f6t\u00fc niyetli bir i\u015fletim sistemi sistemde olsa bile di\u011fer i\u015fletim sistemlerine ula\u015famayacakt\u0131r. Performance: .... syf 63 KVM \u00c7ekirdek Mod\u00fcl\u00fc KVM'nin \u00e7ekirdek mod\u00fcl\u00fc temel sanalla\u015ft\u0131rma i\u015flevlerini yapmaktad\u0131r bunlardan baz\u0131lar\u0131 CPU em\u00fclasyonu, MMU sanalla\u015ft\u0131rmas\u0131 vb. Ancak KVM giri\u015f \u00e7\u0131k\u0131\u015f sistemleri i\u00e7in bir sanalla\u015ft\u0131rma yapmaz [63]. KVM API Kaynaklar - KVM API D\u00f6k\u00fcman\u0131 - Linux KVM B\u00f6l\u00fcm\u00fc \u0130\u00e7indekiler - KVM API - KVM_CAP_XSAVE - KVM_CAP_XCRS - KVM_CAP_VCPU_EVENTS - KVM_CAP_DEBUGREGS - KVM_CAP_HYPERV_EVENTFD - KVM_CAP_HYPERV_CPUID - KVM_CAP_SET_TSS_ADDR - KVM_CAP_IRQCHIP - KVM_CAP_PIT - KVM_CAP_PIT2 - KVM_CAP_ENABLE_CAP - KVM_CAP_PMU_EVENT_FILTER - KVM_CAP_SET_IDENTITY_MAP_ADDR - KVM_CAP_X86_MSR_FILTER - KVM_CAP_MCE KVM_CAP_XSAVE KVM_CAP_XSAVE bayra\u011f\u0131 ile gelen \u00f6zellik KVM_GET_XSAVE ve KVM_SET_XSAVE ioctl'lar\u0131 ile y\u00f6netilebiliyor; x86 \u00fczerinde KVM_GET_XSAVE ve KVM_SET_XSAVE bayra\u011f\u0131 \u00e7ekirdek taraf\u0131nda kvm_vcpu_ioctl_x86_get_xsave(struct kvm_vcpu *vcpu, struct kvm_xsave *guest_xsave) kvm_vcpu_ioctl_x86_set_xsave(struct kvm_vcpu *vcpu, struct kvm_xsave *guest_xsave) fonksiyonuna dallan\u0131yor. 4.42) KVM_GET_XSAVE: Bu ioctl, vcpu'nun xsave struct'\u0131n\u0131 belirtilen userspace'e kopyalar. 4.43) KVM_SET_XSAVE: Bu ioctl, vcpu'nun xsave struct'\u0131n\u0131 belirtilen userspace'e ayarlar. KVM_CAP_XCRS KVM_CAP_XCRS bayra\u011f\u0131 ile gelen \u00f6zellik KVM_GET_XCRS ve KVM_SET_XCRS ioctl'lar\u0131 ile y\u00f6netilebiliyor; x86 \u00fczerinden KVM_CAP_XCRS bayra\u011f\u0131 \u00e7ekirdek taraf\u0131nda kvm_vcpu_ioctl_x86_get_xcrs() kvm_vcpu_ioctl_x86_set_xcrs() fonksiyonuna dallan\u0131yor. 4.44) KVM_GET_XCRS: Bu ioctl, vcpu'nun xcr'sini belirtilen userspace'e kopyalar. 4.45) KVM_SET_XCRS: Bu ioctl, vcpu'nun xcr'sini belirtilen userspace'e ayarlar. KVM_CAP_VCPU_EVENTS KVM_CAP_VCPU_EVENTS bayra\u011f\u0131 ile gelen \u00f6zellik KVM_GET_VCPU_EVENTS ve KVM_SET_VCPU_EVENTS ioctl'lar\u0131 ile y\u00f6netilebiliyor; x86 \u00fczerinde KVM_GET_VCPU_EVENTS ve KVM_SET_VCPU_EVENTS bayraklar\u0131 \u00e7ekirdek taraf\u0131nda kvm_vcpu_ioctl_x86_get_vcpu_events() kvm_vcpu_ioctl_x86_set_vcpu_events() fonksiyonuna dallan\u0131yor. 4.31) KVM_GET_VCPU_EVENTS: \u015eu anda bekleyen exception'lar\u0131, interrupt'lar\u0131 ve NMI'leri ve ayr\u0131ca vcpu'nun ilgili durumlar\u0131n\u0131 al\u0131r. 4.32) KVM_SET_VCPU_EVENTS: \u015eu anda bekleyen exception'lar\u0131, interrupt'lar\u0131 ve NMI'leri vcpu'lara yazar. KVM_CAP_DEBUGREGS KVM_CAP_DEBUGREGS bayra\u011f\u0131 ile gelen \u00f6zellik KVM_GET_DEBUGREGS ve KVM_SET_DEBUGREGS ioctl'lar\u0131 ile y\u00f6netilebiliyor; x86 \u00fczerinde KVM_GET_DEBUGREGS ve KVM_SET_DEBUGREGS bayraklar\u0131 \u00e7ekirdek taraf\u0131nda kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu, struct kvm_debugregs *dbgregs) kvm_vcpu_ioctl_x86_set_debugregs(struct kvm_vcpu *vcpu, struct kvm_debugregs *dbgregs) fonksiyonuna dallan\u0131yor. 4.33) KVM_GET_DEBUGREGS: Vcpu'dan debug register'\u0131n\u0131 okur. 4.44) KVM_SET_DEBUGREGS Vcpu'dan debug register'\u0131na yazar. KVM_CAP_HYPERV_EVENTFD KVM_CAP_HYPERV_EVENTFD bayra\u011f\u0131 ile gelen \u00f6zellik KVM_HYPERV_EVENTFD ioctl'lar\u0131 ile y\u00f6netilebiliyor; x86 \u00fczerinde KVM_HYPERV_EVENTFD bayra\u011f\u0131 \u00e7ekirdek taraf\u0131nda kvm_vm_ioctl_hv_eventfd(struct kvm *kvm, struct kvm_hyperv_eventfd *args) fonksiyonuna dallan\u0131yor. 4.113) KVM_HYPERV_EVENTFD: Bu ioctl (un), bir kullan\u0131c\u0131n\u0131n \u00e7\u0131k\u0131\u015f\u0131na neden olmadan SIGNAL_EVENT hypercall'\u0131 arac\u0131l\u0131\u011f\u0131yla belirtilen Hyper-V ba\u011flant\u0131 kimli\u011fine ili\u015fkin konuktan bildirimler almak i\u00e7in eventfd'yi kaydeder. KVM_CAP_HYPERV_CPUID KVM_CAP_HYPERV_CPUID bayra\u011f\u0131 ile gelen \u00f6zellik KVM_GET_SUPPORTED_HV_CPUID ioctl'lar\u0131 ile y\u00f6netilebiliyor; x86 \u00fczerinde KVM_GET_SUPPORTED_HV_CPUID bayra\u011f\u0131 \u00e7ekirdek taraf\u0131nda kvm_ioctl_get_supported_hv_cpuid(struct kvm_vcpu *vcpu, struct kvm_cpuid2 __user *cpuid_arg) fonksiyonuna dallan\u0131yor. 4.118) KVM_GET_SUPPORTED_HV_CPUID: Bu ioctl, KVM'deki Hyper-V emulasyonu ile ilgili x86 cpuid \u00f6zellikleri d\u00f6nd\u00fcr. KVM_CAP_SET_TSS_ADDR KVM_CAP_SET_TSS_ADDR bayra\u011f\u0131 ile gelen \u00f6zellik KVM_SET_TSS_ADDR ioctl'lar\u0131 ile y\u00f6netilebiliyor; x86 \u00fczerinde KVM_SET_TSS_ADDR bayra\u011f\u0131 \u00e7ekirdek taraf\u0131nda kvm_vm_ioctl_set_tss_addr(struct kvm *kvm, unsigned long addr) fonksiyonuna dallan\u0131yor. 4.38) KVM_SET_TSS_ADDR: Bu ioctl konuk bilgisayar\u0131n three-page b\u00f6lgesinin fiziksel adresini tan\u0131mlar. KVM_CAP_IRQCHIP KVM_CAP_IRQCHIP bayra\u011f\u0131 ile gelen \u00f6zellik KVM_CREATE_IRQCHIP, KVM_GET_IRQCHIP ve KVM_SET_IRQCHIP ioctl'lar\u0131 ile y\u00f6netilebiliyor; x86 \u00fczerinde KVM_GET_IRQCHIP ve KVM_SET_IRQCHIP bayra\u011f\u0131 \u00e7ekirdek taraf\u0131nda kvm_vm_ioctl_get_irqchip(struct kvm *kvm, struct kvm_irqchip *chip) kvm_vm_ioctl_set_irqchip(struct kvm *kvm, struct kvm_irqchip *chip) fonksiyonlar\u0131na dallan\u0131yor. 4.26) KVM_GET_IRQCHIP: Caller taraf\u0131ndan sa\u011flanan bir arabelle\u011fe KVM_CREATE_IRQCHIP ile olu\u015fturulan \u00e7ekirdek interrupt denetleyicisinin durumunu okur. 4.27) KVM_SET_IRQCHIP: Caller taraf\u0131ndan sa\u011flanan bir arabelle\u011fe KVM_CREATE_IRQCHIP ile olu\u015fturulan \u00e7ekirdek interrupt denetleyicisinin durumunu yazar. KVM_CAP_PIT KVM_CAP_PIT bayra\u011f\u0131 ile gelen \u00f6zellik KVM_GET_PIT ve KVM_SET_PIT ioctl'lar\u0131 ile y\u00f6netilebiliyor; x86 \u00fczerinde KVM_GET_PIT ve KVM_SET_PIT bayraklar\u0131 \u00e7ekirdek taraf\u0131nda kvm_vm_ioctl_get_pit(struct kvm *kvm, struct kvm_pit_state *ps) kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps) fonksiyonlar\u0131na dallan\u0131yor. G\u00fcncel KVM d\u00f6k\u00fcman\u0131nda a\u00e7\u0131klama bulamad\u0131m. KVM_CAP_PIT2 KVM_CAP_PIT2 bayra\u011f\u0131 ile gelen \u00f6zellik KVM_GET_PIT2 ve KVM_SET_PIT2 ioctl'lar\u0131 ile y\u00f6netilebiliyor; x86 \u00fczerinde KVM_GET_PIT2 ve KVM_SET_PIT2 bayraklar\u0131 \u00e7ekirdek taraf\u0131nda kvm_vm_ioctl_get_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps) kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps) fonksiyonlar\u0131na dallan\u0131yor. 4.72) KVM_GET_PIT2: \u00c7ekirdek i\u00e7erisindeki PIT modelinin durumunu d\u00f6nd\u00fcr\u00fcr. 4.73) KVM_GET_PIT2: \u00c7ekirdek i\u00e7erisindeki PIT modelinin durumuna yazar. KVM_CAP_ENABLE_CAP KVM_CAP_ENABLE_CAP bayra\u011f\u0131 ile gelen \u00f6zellik KVM_ENABLE_CAP ioctl'lar\u0131 ile y\u00f6netilebiliyor; x86 \u00fczerinde KVM_ENABLE_CAP bayraklar\u0131 \u00e7ekirdek taraf\u0131nda kvm_vm_ioctl_enable_cap(struct kvm *kvm,struct kvm_enable_cap *cap) fonksiyonlar\u0131na dallan\u0131yor. 4.37) KVM_ENABLE_CAP: KVM'de varsay\u0131lan olarak t\u00fcm uzant\u0131lar etkin olarak gelmiyor. Uygulama, bu ioctl'yi kullanarak bir eklentiyi etkinle\u015ftirebilir ve konuk kullan\u0131c\u0131n\u0131n kullan\u0131m\u0131na sunabilir. KVM_CAP_PMU_EVENT_FILTER KVM_CAP_PMU_EVENT_FILTER bayra\u011f\u0131 ile gelen \u00f6zellik KVM_SET_PMU_EVENT_FILTER ioctl'lar\u0131 ile y\u00f6netilebiliyor; x86 \u00fczerinde KVM_SET_PMU_EVENT_FILTER bayraklar\u0131 \u00e7ekirdek taraf\u0131nda kvm_vm_ioctl_set_pmu_event_filter(struct kvm *kvm, void __user *argp) fonksiyonlar\u0131na dallan\u0131yor. 4.120) KVM_SET_PMU_EVENT_FILTER: Bu ioctl kullan\u0131c\u0131n\u0131n yapabilece\u011fi PMU olaylar\u0131n\u0131 k\u0131s\u0131tlar. KVM_CAP_SET_IDENTITY_MAP_ADDR KVM_CAP_SET_IDENTITY_MAP_ADDR bayra\u011f\u0131 ile gelen \u00f6zellik KVM_SET_IDENTITY_MAP_ADDR ioctl'lar\u0131 ile y\u00f6netilebiliyor; x86 \u00fczerinde KVM_SET_IDENTITY_MAP_ADDR bayraklar\u0131 \u00e7ekirdek taraf\u0131nda kvm_vm_ioctl_set_identity_map_addr(struct kvm *kvm, u64 ident_addr) fonksiyonlar\u0131na dallan\u0131yor. 4.40) KVM_SET_IDENTITY_MAP_ADDR: Bu ioctl, konuk kullan\u0131c\u0131n\u0131n fiziksel adres alan\u0131ndaki one-page b\u00f6lgenin fiziksel adresini tan\u0131mlar. KVM_CAP_X86_MSR_FILTER KVM_CAP_X86_MSR_FILTER bayra\u011f\u0131 ile gelen \u00f6zellik KVM_X86_SET_MSR_FILTER ioctl'lar\u0131 ile y\u00f6netilebiliyor; x86 \u00fczerinde KVM_X86_SET_MSR_FILTER bayraklar\u0131 \u00e7ekirdek taraf\u0131nda kvm_vm_ioctl_set_msr_filter(struct kvm *kvm, void __user *argp) fonksiyonlar\u0131na dallan\u0131yor. KVM_CAP_MCE KVM_CAP_MCE bayra\u011f\u0131 ile gelen \u00f6zellik KVM_X86_SET_MCE, KVM_X86_GET_MCE_CAP_SUPPORTED ioctl'lar\u0131 ile y\u00f6netilebiliyor; x86 \u00fczerinde KVM_X86_SET_MCE, KVM_X86_GET_MCE_CAP_SUPPORTED bayraklar\u0131 \u00e7ekirdek taraf\u0131nda kvm_vcpu_ioctl_x86_setup_mce(struct kvm_vcpu *vcpu, u64 mcg_cap) kvm_vcpu_ioctl_x86_set_mce(struct kvm_vcpu *vcpu, struct kvm_x86_mce *mce) u64 __read_mostly kvm_mce_cap_supported = MCG_CTL_P | MCG_SER_P; fonksiyonlar\u0131na ve de\u011fi\u015fkenlere dallan\u0131yor. 4.105) KVM_X86_SETUP_MCE: : Makine onay hata kodu'nu (MCE) olu\u015fturur. 4.106) KVM_X86_SET_MCE: Makine onay hata kodu'nu (MCE) konuk kullan\u0131c\u0131n\u0131n i\u00e7ine yerle\u015ftirir.","title":"KVM"},{"location":"kvm/#kvm-nedir","text":"KVM, Linux \u00e7ekirde\u011fini tip-1 hypervisor'e d\u00f6n\u00fc\u015ft\u00fcren bir mod\u00fcld\u00fcr. Ayn\u0131 zamanda QEMU ile birle\u015ferek tip-2 hyperviz\u00f6r'e d\u00f6n\u00fc\u015ft\u00fcrebilmektedir. X86 i\u015flemciler i\u00e7in tasarlanm\u0131\u015ft\u0131r. KVM, sanalla\u015ft\u0131rmak i\u00e7in Intel VT-x veya AMD-V gibi \u00f6zel donan\u0131m gerektirir. KVM geli\u015ftiricileri Popek ve Goldberg'in \u00f6nerdi\u011fi 3 temel \u015fart\u0131 \u015fu \u015fekilde sa\u011flam\u0131\u015flard\u0131r. Equivalence: KVM, herhangi bir i\u015fletim sistemi fark\u0131 olmadan ve bir de\u011fi\u015fiklik yapmadan herhangi bir x86 i\u015fletim sistemini \u00e7al\u0131\u015ft\u0131rabilmelidir. Safety: KVM, sanal makineler aras\u0131nda b\u00fct\u00fcn bir izolasyon sa\u011flamaktad\u0131r. Bunun i\u00e7in CPU, fiziksel haf\u0131za, BIOS yaz\u0131l\u0131m\u0131 gibi par\u00e7alar da sanalla\u015ft\u0131r\u0131lmaktad\u0131r. Bununla birlikte k\u00f6t\u00fc niyetli bir i\u015fletim sistemi sistemde olsa bile di\u011fer i\u015fletim sistemlerine ula\u015famayacakt\u0131r. Performance: .... syf 63","title":"KVM Nedir"},{"location":"kvm/#kvm-cekirdek-modulu","text":"KVM'nin \u00e7ekirdek mod\u00fcl\u00fc temel sanalla\u015ft\u0131rma i\u015flevlerini yapmaktad\u0131r bunlardan baz\u0131lar\u0131 CPU em\u00fclasyonu, MMU sanalla\u015ft\u0131rmas\u0131 vb. Ancak KVM giri\u015f \u00e7\u0131k\u0131\u015f sistemleri i\u00e7in bir sanalla\u015ft\u0131rma yapmaz [63].","title":"KVM \u00c7ekirdek Mod\u00fcl\u00fc"},{"location":"kvm/#kvm-api","text":"Kaynaklar - KVM API D\u00f6k\u00fcman\u0131 - Linux KVM B\u00f6l\u00fcm\u00fc \u0130\u00e7indekiler - KVM API - KVM_CAP_XSAVE - KVM_CAP_XCRS - KVM_CAP_VCPU_EVENTS - KVM_CAP_DEBUGREGS - KVM_CAP_HYPERV_EVENTFD - KVM_CAP_HYPERV_CPUID - KVM_CAP_SET_TSS_ADDR - KVM_CAP_IRQCHIP - KVM_CAP_PIT - KVM_CAP_PIT2 - KVM_CAP_ENABLE_CAP - KVM_CAP_PMU_EVENT_FILTER - KVM_CAP_SET_IDENTITY_MAP_ADDR - KVM_CAP_X86_MSR_FILTER - KVM_CAP_MCE","title":"KVM API"},{"location":"kvm/#kvm_cap_xsave","text":"KVM_CAP_XSAVE bayra\u011f\u0131 ile gelen \u00f6zellik KVM_GET_XSAVE ve KVM_SET_XSAVE ioctl'lar\u0131 ile y\u00f6netilebiliyor; x86 \u00fczerinde KVM_GET_XSAVE ve KVM_SET_XSAVE bayra\u011f\u0131 \u00e7ekirdek taraf\u0131nda kvm_vcpu_ioctl_x86_get_xsave(struct kvm_vcpu *vcpu, struct kvm_xsave *guest_xsave) kvm_vcpu_ioctl_x86_set_xsave(struct kvm_vcpu *vcpu, struct kvm_xsave *guest_xsave) fonksiyonuna dallan\u0131yor. 4.42) KVM_GET_XSAVE: Bu ioctl, vcpu'nun xsave struct'\u0131n\u0131 belirtilen userspace'e kopyalar. 4.43) KVM_SET_XSAVE: Bu ioctl, vcpu'nun xsave struct'\u0131n\u0131 belirtilen userspace'e ayarlar.","title":"KVM_CAP_XSAVE"},{"location":"kvm/#kvm_cap_xcrs","text":"KVM_CAP_XCRS bayra\u011f\u0131 ile gelen \u00f6zellik KVM_GET_XCRS ve KVM_SET_XCRS ioctl'lar\u0131 ile y\u00f6netilebiliyor; x86 \u00fczerinden KVM_CAP_XCRS bayra\u011f\u0131 \u00e7ekirdek taraf\u0131nda kvm_vcpu_ioctl_x86_get_xcrs() kvm_vcpu_ioctl_x86_set_xcrs() fonksiyonuna dallan\u0131yor. 4.44) KVM_GET_XCRS: Bu ioctl, vcpu'nun xcr'sini belirtilen userspace'e kopyalar. 4.45) KVM_SET_XCRS: Bu ioctl, vcpu'nun xcr'sini belirtilen userspace'e ayarlar.","title":"KVM_CAP_XCRS"},{"location":"kvm/#kvm_cap_vcpu_events","text":"KVM_CAP_VCPU_EVENTS bayra\u011f\u0131 ile gelen \u00f6zellik KVM_GET_VCPU_EVENTS ve KVM_SET_VCPU_EVENTS ioctl'lar\u0131 ile y\u00f6netilebiliyor; x86 \u00fczerinde KVM_GET_VCPU_EVENTS ve KVM_SET_VCPU_EVENTS bayraklar\u0131 \u00e7ekirdek taraf\u0131nda kvm_vcpu_ioctl_x86_get_vcpu_events() kvm_vcpu_ioctl_x86_set_vcpu_events() fonksiyonuna dallan\u0131yor. 4.31) KVM_GET_VCPU_EVENTS: \u015eu anda bekleyen exception'lar\u0131, interrupt'lar\u0131 ve NMI'leri ve ayr\u0131ca vcpu'nun ilgili durumlar\u0131n\u0131 al\u0131r. 4.32) KVM_SET_VCPU_EVENTS: \u015eu anda bekleyen exception'lar\u0131, interrupt'lar\u0131 ve NMI'leri vcpu'lara yazar.","title":"KVM_CAP_VCPU_EVENTS"},{"location":"kvm/#kvm_cap_debugregs","text":"KVM_CAP_DEBUGREGS bayra\u011f\u0131 ile gelen \u00f6zellik KVM_GET_DEBUGREGS ve KVM_SET_DEBUGREGS ioctl'lar\u0131 ile y\u00f6netilebiliyor; x86 \u00fczerinde KVM_GET_DEBUGREGS ve KVM_SET_DEBUGREGS bayraklar\u0131 \u00e7ekirdek taraf\u0131nda kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu, struct kvm_debugregs *dbgregs) kvm_vcpu_ioctl_x86_set_debugregs(struct kvm_vcpu *vcpu, struct kvm_debugregs *dbgregs) fonksiyonuna dallan\u0131yor. 4.33) KVM_GET_DEBUGREGS: Vcpu'dan debug register'\u0131n\u0131 okur. 4.44) KVM_SET_DEBUGREGS Vcpu'dan debug register'\u0131na yazar.","title":"KVM_CAP_DEBUGREGS"},{"location":"kvm/#kvm_cap_hyperv_eventfd","text":"KVM_CAP_HYPERV_EVENTFD bayra\u011f\u0131 ile gelen \u00f6zellik KVM_HYPERV_EVENTFD ioctl'lar\u0131 ile y\u00f6netilebiliyor; x86 \u00fczerinde KVM_HYPERV_EVENTFD bayra\u011f\u0131 \u00e7ekirdek taraf\u0131nda kvm_vm_ioctl_hv_eventfd(struct kvm *kvm, struct kvm_hyperv_eventfd *args) fonksiyonuna dallan\u0131yor. 4.113) KVM_HYPERV_EVENTFD: Bu ioctl (un), bir kullan\u0131c\u0131n\u0131n \u00e7\u0131k\u0131\u015f\u0131na neden olmadan SIGNAL_EVENT hypercall'\u0131 arac\u0131l\u0131\u011f\u0131yla belirtilen Hyper-V ba\u011flant\u0131 kimli\u011fine ili\u015fkin konuktan bildirimler almak i\u00e7in eventfd'yi kaydeder.","title":"KVM_CAP_HYPERV_EVENTFD"},{"location":"kvm/#kvm_cap_hyperv_cpuid","text":"KVM_CAP_HYPERV_CPUID bayra\u011f\u0131 ile gelen \u00f6zellik KVM_GET_SUPPORTED_HV_CPUID ioctl'lar\u0131 ile y\u00f6netilebiliyor; x86 \u00fczerinde KVM_GET_SUPPORTED_HV_CPUID bayra\u011f\u0131 \u00e7ekirdek taraf\u0131nda kvm_ioctl_get_supported_hv_cpuid(struct kvm_vcpu *vcpu, struct kvm_cpuid2 __user *cpuid_arg) fonksiyonuna dallan\u0131yor. 4.118) KVM_GET_SUPPORTED_HV_CPUID: Bu ioctl, KVM'deki Hyper-V emulasyonu ile ilgili x86 cpuid \u00f6zellikleri d\u00f6nd\u00fcr.","title":"KVM_CAP_HYPERV_CPUID"},{"location":"kvm/#kvm_cap_set_tss_addr","text":"KVM_CAP_SET_TSS_ADDR bayra\u011f\u0131 ile gelen \u00f6zellik KVM_SET_TSS_ADDR ioctl'lar\u0131 ile y\u00f6netilebiliyor; x86 \u00fczerinde KVM_SET_TSS_ADDR bayra\u011f\u0131 \u00e7ekirdek taraf\u0131nda kvm_vm_ioctl_set_tss_addr(struct kvm *kvm, unsigned long addr) fonksiyonuna dallan\u0131yor. 4.38) KVM_SET_TSS_ADDR: Bu ioctl konuk bilgisayar\u0131n three-page b\u00f6lgesinin fiziksel adresini tan\u0131mlar.","title":"KVM_CAP_SET_TSS_ADDR"},{"location":"kvm/#kvm_cap_irqchip","text":"KVM_CAP_IRQCHIP bayra\u011f\u0131 ile gelen \u00f6zellik KVM_CREATE_IRQCHIP, KVM_GET_IRQCHIP ve KVM_SET_IRQCHIP ioctl'lar\u0131 ile y\u00f6netilebiliyor; x86 \u00fczerinde KVM_GET_IRQCHIP ve KVM_SET_IRQCHIP bayra\u011f\u0131 \u00e7ekirdek taraf\u0131nda kvm_vm_ioctl_get_irqchip(struct kvm *kvm, struct kvm_irqchip *chip) kvm_vm_ioctl_set_irqchip(struct kvm *kvm, struct kvm_irqchip *chip) fonksiyonlar\u0131na dallan\u0131yor. 4.26) KVM_GET_IRQCHIP: Caller taraf\u0131ndan sa\u011flanan bir arabelle\u011fe KVM_CREATE_IRQCHIP ile olu\u015fturulan \u00e7ekirdek interrupt denetleyicisinin durumunu okur. 4.27) KVM_SET_IRQCHIP: Caller taraf\u0131ndan sa\u011flanan bir arabelle\u011fe KVM_CREATE_IRQCHIP ile olu\u015fturulan \u00e7ekirdek interrupt denetleyicisinin durumunu yazar.","title":"KVM_CAP_IRQCHIP"},{"location":"kvm/#kvm_cap_pit","text":"KVM_CAP_PIT bayra\u011f\u0131 ile gelen \u00f6zellik KVM_GET_PIT ve KVM_SET_PIT ioctl'lar\u0131 ile y\u00f6netilebiliyor; x86 \u00fczerinde KVM_GET_PIT ve KVM_SET_PIT bayraklar\u0131 \u00e7ekirdek taraf\u0131nda kvm_vm_ioctl_get_pit(struct kvm *kvm, struct kvm_pit_state *ps) kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps) fonksiyonlar\u0131na dallan\u0131yor. G\u00fcncel KVM d\u00f6k\u00fcman\u0131nda a\u00e7\u0131klama bulamad\u0131m.","title":"KVM_CAP_PIT"},{"location":"kvm/#kvm_cap_pit2","text":"KVM_CAP_PIT2 bayra\u011f\u0131 ile gelen \u00f6zellik KVM_GET_PIT2 ve KVM_SET_PIT2 ioctl'lar\u0131 ile y\u00f6netilebiliyor; x86 \u00fczerinde KVM_GET_PIT2 ve KVM_SET_PIT2 bayraklar\u0131 \u00e7ekirdek taraf\u0131nda kvm_vm_ioctl_get_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps) kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps) fonksiyonlar\u0131na dallan\u0131yor. 4.72) KVM_GET_PIT2: \u00c7ekirdek i\u00e7erisindeki PIT modelinin durumunu d\u00f6nd\u00fcr\u00fcr. 4.73) KVM_GET_PIT2: \u00c7ekirdek i\u00e7erisindeki PIT modelinin durumuna yazar.","title":"KVM_CAP_PIT2"},{"location":"kvm/#kvm_cap_enable_cap","text":"KVM_CAP_ENABLE_CAP bayra\u011f\u0131 ile gelen \u00f6zellik KVM_ENABLE_CAP ioctl'lar\u0131 ile y\u00f6netilebiliyor; x86 \u00fczerinde KVM_ENABLE_CAP bayraklar\u0131 \u00e7ekirdek taraf\u0131nda kvm_vm_ioctl_enable_cap(struct kvm *kvm,struct kvm_enable_cap *cap) fonksiyonlar\u0131na dallan\u0131yor. 4.37) KVM_ENABLE_CAP: KVM'de varsay\u0131lan olarak t\u00fcm uzant\u0131lar etkin olarak gelmiyor. Uygulama, bu ioctl'yi kullanarak bir eklentiyi etkinle\u015ftirebilir ve konuk kullan\u0131c\u0131n\u0131n kullan\u0131m\u0131na sunabilir.","title":"KVM_CAP_ENABLE_CAP"},{"location":"kvm/#kvm_cap_pmu_event_filter","text":"KVM_CAP_PMU_EVENT_FILTER bayra\u011f\u0131 ile gelen \u00f6zellik KVM_SET_PMU_EVENT_FILTER ioctl'lar\u0131 ile y\u00f6netilebiliyor; x86 \u00fczerinde KVM_SET_PMU_EVENT_FILTER bayraklar\u0131 \u00e7ekirdek taraf\u0131nda kvm_vm_ioctl_set_pmu_event_filter(struct kvm *kvm, void __user *argp) fonksiyonlar\u0131na dallan\u0131yor. 4.120) KVM_SET_PMU_EVENT_FILTER: Bu ioctl kullan\u0131c\u0131n\u0131n yapabilece\u011fi PMU olaylar\u0131n\u0131 k\u0131s\u0131tlar.","title":"KVM_CAP_PMU_EVENT_FILTER"},{"location":"kvm/#kvm_cap_set_identity_map_addr","text":"KVM_CAP_SET_IDENTITY_MAP_ADDR bayra\u011f\u0131 ile gelen \u00f6zellik KVM_SET_IDENTITY_MAP_ADDR ioctl'lar\u0131 ile y\u00f6netilebiliyor; x86 \u00fczerinde KVM_SET_IDENTITY_MAP_ADDR bayraklar\u0131 \u00e7ekirdek taraf\u0131nda kvm_vm_ioctl_set_identity_map_addr(struct kvm *kvm, u64 ident_addr) fonksiyonlar\u0131na dallan\u0131yor. 4.40) KVM_SET_IDENTITY_MAP_ADDR: Bu ioctl, konuk kullan\u0131c\u0131n\u0131n fiziksel adres alan\u0131ndaki one-page b\u00f6lgenin fiziksel adresini tan\u0131mlar.","title":"KVM_CAP_SET_IDENTITY_MAP_ADDR"},{"location":"kvm/#kvm_cap_x86_msr_filter","text":"KVM_CAP_X86_MSR_FILTER bayra\u011f\u0131 ile gelen \u00f6zellik KVM_X86_SET_MSR_FILTER ioctl'lar\u0131 ile y\u00f6netilebiliyor; x86 \u00fczerinde KVM_X86_SET_MSR_FILTER bayraklar\u0131 \u00e7ekirdek taraf\u0131nda kvm_vm_ioctl_set_msr_filter(struct kvm *kvm, void __user *argp) fonksiyonlar\u0131na dallan\u0131yor.","title":"KVM_CAP_X86_MSR_FILTER"},{"location":"kvm/#kvm_cap_mce","text":"KVM_CAP_MCE bayra\u011f\u0131 ile gelen \u00f6zellik KVM_X86_SET_MCE, KVM_X86_GET_MCE_CAP_SUPPORTED ioctl'lar\u0131 ile y\u00f6netilebiliyor; x86 \u00fczerinde KVM_X86_SET_MCE, KVM_X86_GET_MCE_CAP_SUPPORTED bayraklar\u0131 \u00e7ekirdek taraf\u0131nda kvm_vcpu_ioctl_x86_setup_mce(struct kvm_vcpu *vcpu, u64 mcg_cap) kvm_vcpu_ioctl_x86_set_mce(struct kvm_vcpu *vcpu, struct kvm_x86_mce *mce) u64 __read_mostly kvm_mce_cap_supported = MCG_CTL_P | MCG_SER_P; fonksiyonlar\u0131na ve de\u011fi\u015fkenlere dallan\u0131yor. 4.105) KVM_X86_SETUP_MCE: : Makine onay hata kodu'nu (MCE) olu\u015fturur. 4.106) KVM_X86_SET_MCE: Makine onay hata kodu'nu (MCE) konuk kullan\u0131c\u0131n\u0131n i\u00e7ine yerle\u015ftirir.","title":"KVM_CAP_MCE"},{"location":"os/","text":"\u0130\u015fletim Sistemleri Genel Bak\u0131\u015f Process Process bir \u00e7al\u0131\u015fan bir programd\u0131r Bu programlar derlenerek executable haline getirilir. Executable dosyalar\u0131nda CPU instruction'lar\u0131 bulunur. OS bu process'i \u00e7al\u0131\u015ft\u0131rabilmek i\u00e7in RAM'den haf\u0131za ay\u0131r\u0131r. Kod Heap: dinamik i\u015flemler i\u00e7in kullan\u0131lacak malloc vs Stack: return adresler, lokal de\u011fi\u015fkenler burada tutulur. T\u00fcm instructionlar ve de\u011fi\u015flenkler bellekte tutulur ve her birinin adresi vard\u0131r. Process Execution Bir process CPU taraf\u0131ndan \u00e7al\u0131\u015ft\u0131r\u0131l\u0131rken bu program\u0131n \u00e7al\u0131\u015fmas\u0131 i\u00e7in gerekli bilgiler CPU'nun registerlar\u0131na y\u00fcklenir. +--------------+ | +----> Stack Pointer +--------------+ | | +--------------+ | | +--------------+ | | +--------------+ STACK","title":"\u0130\u015fletim Sistemleri Genel Bak\u0131\u015f"},{"location":"os/#isletim-sistemleri-genel-baks","text":"","title":"\u0130\u015fletim Sistemleri Genel Bak\u0131\u015f"},{"location":"os/#process","text":"Process bir \u00e7al\u0131\u015fan bir programd\u0131r Bu programlar derlenerek executable haline getirilir. Executable dosyalar\u0131nda CPU instruction'lar\u0131 bulunur. OS bu process'i \u00e7al\u0131\u015ft\u0131rabilmek i\u00e7in RAM'den haf\u0131za ay\u0131r\u0131r. Kod Heap: dinamik i\u015flemler i\u00e7in kullan\u0131lacak malloc vs Stack: return adresler, lokal de\u011fi\u015fkenler burada tutulur. T\u00fcm instructionlar ve de\u011fi\u015flenkler bellekte tutulur ve her birinin adresi vard\u0131r.","title":"Process"},{"location":"os/#process-execution","text":"Bir process CPU taraf\u0131ndan \u00e7al\u0131\u015ft\u0131r\u0131l\u0131rken bu program\u0131n \u00e7al\u0131\u015fmas\u0131 i\u00e7in gerekli bilgiler CPU'nun registerlar\u0131na y\u00fcklenir. +--------------+ | +----> Stack Pointer +--------------+ | | +--------------+ | | +--------------+ | | +--------------+ STACK","title":"Process Execution"},{"location":"projeler/","text":"Yararl\u0131 Linkler \u00d6rnek proje ve kaynaklar burada listelenecektir. Virtualization Virtualization Hakk\u0131nda Dersler link Awesome Virtualization - link Sistem Programlama CS 361: Systems Programming link KVM KVM-API link KVM-Hello link Implement KVM - link KVM Tool - link KVM Sample - link QEMU QEMU internals link Rust !!Con 2019 - Build your own virtual machine with /dev/kvm and Rust! by Josh Triplett - link","title":"Yararl\u0131 Projeler"},{"location":"projeler/#yararl-linkler","text":"\u00d6rnek proje ve kaynaklar burada listelenecektir.","title":"Yararl\u0131 Linkler"},{"location":"projeler/#virtualization","text":"Virtualization Hakk\u0131nda Dersler link Awesome Virtualization - link","title":"Virtualization"},{"location":"projeler/#sistem-programlama","text":"CS 361: Systems Programming link","title":"Sistem Programlama"},{"location":"projeler/#kvm","text":"KVM-API link KVM-Hello link Implement KVM - link KVM Tool - link KVM Sample - link","title":"KVM"},{"location":"projeler/#qemu","text":"QEMU internals link","title":"QEMU"},{"location":"projeler/#rust","text":"!!Con 2019 - Build your own virtual machine with /dev/kvm and Rust! by Josh Triplett - link","title":"Rust"}]}